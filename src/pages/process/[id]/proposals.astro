---
import i18next, { t, changeLanguage } from "i18next";
import ProcessLayout from "templates/ProcessLayout.astro";
import getProcessUrl from "composables/getProcessUrl";
import fetchProcessData from "composables/fetchProcessData";
import AddProposals from "molecules/AddProposals.astro";
import AlertManager from "molecules/AlertManager.astro";
import Alert from "atoms/Alert.astro";

changeLanguage("en");

const { url } = Astro;
const processId = Astro.params.id;
const process = await fetchProcessData(processId, url);
const pathname = `${i18next.language === "en" ? "" : `/${i18next.language}`}${getProcessUrl(process, processId)}`;
if (pathname !== url.pathname)
    return Astro.redirect;
---

<ProcessLayout process={process}>
    <proposal-list>
        <h2>{ t('process.proposals') }</h2>
        <div class="proposals">
            <div class="proposal bg-base-100 card shadow-xl py-2 px-4 my-4">
                <div class="view flex justify-between items-center cursor-pointer">
                    <div class="content flex flex-col w-full">
                        <div class="flex flex-col"/>
                        <div class="flex">
                            <button name="edit" class="btn btn-primary  btn-sm mx-2">{ t('edit') }</button>
                        </div>
                    </div>
                </div>
                <div class="edit flex justify-between items-center" style="display: none;">
                    <div class="content flex flex-col w-full">
                        <b>{ t('process.proposal') }</b>
                        <input type="text" class="input input-bordered input-sm my-2"/>
                        <label>{ t('process.description') }</label>
                        <div class="quill"/>
                        <br/>
                        <div class="flex">
                            <button name="save" class="btn btn-primary btn-sm mx-2">
                                { t('save') }
                            </button>
                            <button name="delete" class="btn btn-ghost text-error btn-sm mx-2">
                                { t('delete') }
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <AddProposals processId={processId}/>

        <AlertManager>
            <Alert icon="checkmark-outline" success>
                { t('alert.success.websocketConnected') }
                <span class="name"></span>
            </Alert>
            <Alert icon="checkmark-outline">
                { t('alert.warning.connectingToWebsocket') }
            </Alert>
            <Alert icon="checkmark-outline" error>
                { t('alert.error.errorConnectingToWebsocket') }
            </Alert>
        </AlertManager>
    </proposal-list> 
</ProcessLayout>

<script>
    import { addAlert } from 'composables/addAlert'
    import IProposal from "interfaces/IProposal"
    import processTest from "composables/processTestData";
    import createQuill from "composables/quillEditor";
    import { Delta } from "quill"

    const processId = window.location.pathname.split('/process/')[1].split('/')[0]
    const isDev = processId === 'dev';

    const res = isDev ? new Response() : await fetch(`${location.origin}/api/process/${processId}`, { method: "GET" });
    const data = isDev ? null : await res.json();
    const process = isDev ? processTest() : JSON.parse(data.process)
    const protocol = window.location.protocol === 'http:' ? 'ws:' : 'wss:'
    const ws = new WebSocket(`${protocol}//${window.location.host}`);

    class ProposalList extends HTMLElement {
        proposal_html = null
        proposals = null
        descriptionQuills = {}
        alertList = this.querySelector('div.alert-manager').querySelector('div.alert-list')
        alerts = this.querySelector('div.alert-manager').querySelectorAll('div.alert')
     
        updateProposalView(proposal: any, title: string, description: string ) {
            const view_content = proposal.querySelector('div.view').querySelector('div.content').querySelector('.flex')
            view_content.innerHTML = `
                <h3>${title}</h3>
                <p>${description}</p>`
        }
        
        updateProposalEdit(proposal: any, title: string, description: Delta): HTMLInputElement {
            const edit_content = proposal.querySelector('div.edit').querySelector('div')
            const inputs = [
                edit_content.querySelector("input"),
                edit_content.querySelector(".quill"),
            ];
            inputs[0].value = title
            this.descriptionQuills[inputs[1].id].setContents(typeof description === "string" ? { ops: [{ insert: description }] } : description);
            return inputs[1]
        }
        
        updateProposal(inputs: any[], proposal: IProposal) {
            const description_content = this.descriptionQuills[inputs[1].id].getContents()

            if (inputs[0].value === '' && inputs[1].innerHTML === '') {
                ws.send(JSON.stringify({
                    method: 'removeProposal',
                    proposalId: proposal.id,
                    processId
                }));
            } else {
                ws.send(JSON.stringify({
                    method: 'updateProposal',
                    title: inputs[0].value,
                    description: description_content,
                    proposalId: proposal.id,
                    processId
                }));
            }

            const html_description = inputs[1].querySelector('.ql-editor').innerHTML

            this.updateProposalView(proposal, inputs[0].value, html_description);
        }

        addProposal(data: IProposal, editing: boolean = false) {
            // Clone proposal HTML element and set its ID to data ID
            const proposal = this.proposal_html.cloneNode(true);
            proposal.id = data.id;
            
            // Get view and edit element inside proposal element and update view with new proposal data
            const view = proposal.querySelector('div.view');
            const edit = proposal.querySelector('div.edit');
            
            // If editing is true, hide view, show edit
            if (editing) {
              view.style.display = 'none'
              edit.style.display = 'flex'
            }
            
            // Add event listener to view so that it becomes hidden when clicked and edit view becomes visible
            view.addEventListener('click', () => {
              view.style.display = 'none'
              edit.style.display = 'flex'
            })
            
            // Get input elements within edit content element and add keyup event listener
            const edit_content = edit.querySelector('div')
            const inputs = [
              edit_content.querySelector('input'),
              edit_content.querySelector('.quill')
            ];
              
            inputs[0].value = data.title
            const proposalId = data.id
            
            const descriptionId = `quill-${proposalId}`; // Unique ID for the Quill editor
            inputs[1].id = descriptionId; 

      
            const save_buttons = edit.querySelectorAll('button')
            save_buttons.forEach((btn: HTMLButtonElement) => {
                btn.addEventListener('click', () => {
                    if (btn.name === 'delete') {
                        inputs[0].value = ''
                        inputs[1].innerHTML = ''
                    }

                    view.style.display = 'flex';
                    edit.style.display = 'none';

                    this.updateProposal(inputs, proposal)
                })
            })
            this.proposals.appendChild(proposal)

            // Create a Quill editor for the description field
        
            const quill = createQuill('#' + descriptionId);
            quill.setContents(typeof data.description === "string" ? { ops: [{ insert: data.description }] } : data.description);
            const html_description = inputs[1].querySelector('.ql-editor').innerHTML
            this.updateProposalView(proposal, data.title, html_description)
            this.descriptionQuills[descriptionId] = quill

            inputs[0].addEventListener('input', () => {
                ws.send(JSON.stringify({
                    method: 'updateProposal',
                    title: inputs[0].value,
                    description: quill.getContents(),
                    processId,
                    proposalId
                }))
            })

        }
        constructor() {
            super();


            if (ws.readyState === WebSocket.CONNECTING) {
                addAlert(this.alertList, this.alerts[0])
                console.log("WebSocket is in the connecting state.");
            }

            ws.addEventListener('open', () => {
                console.log("WebSocket is successfully connected.");
            });

            ws.addEventListener('error', (error) => {
                console.log("Error connecting to WebSocket:", error);
            });

            // Find the proposals container and clone a proposal template.
            this.proposals = this.querySelector('div.proposals');
            this.proposal_html = this.proposals.querySelector('div.proposal').cloneNode(true);
            this.proposals.innerHTML = "";

            // Listen for WebSocket events.
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if ('method' in data) {
                    if (data.method === 'addProposal') {
                        // Add a new proposal.
                        this.addProposal(data.proposal, data.proposal.title ? false : data.edit);
                    } else if (data.method === 'removeProposal') {
                        // Remove a proposal.
                        for (const child of this.proposals.children) {
                            if (child.id === data.proposalId) {
                                this.proposals.removeChild(child);
                                break;
                            }
                        }
                    } else if (data.method === 'updateProposal') {
                        // Update a proposal.
                        for (const child of this.proposals.children) {
                            if (child.id === data.proposalId) {
                                const description_input = this.updateProposalEdit(child, data.title, data.description);
                                const html_description = description_input.querySelector('.ql-editor').innerHTML
                                this.updateProposalView(child, data.title, html_description);
                                break;
                            }
                        }
                    }
                }
            };

            ws.onopen = (event) => {
                // Set the process ID when the WebSocket connection is opened.
                ws.send(JSON.stringify({
                    method: 'setProcess',
                    processId
                }));
            };

            // Add existing proposals to the UI.
            process.proposals.forEach((proposal: any) => {
                this.addProposal(proposal);
            });

        }
    }
    customElements.define('proposal-list', ProposalList)


    const checkTime = () => {
        const time =  process.proposalDates[1] - +new Date()
        if (time <= 0)
            window.location.href = `${window.location.origin}/process/${processId}/voting`
        else
            setTimeout(checkTime, time)
    }
    checkTime()

        

</script>